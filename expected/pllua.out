--
CREATE EXTENSION pllua_ng;
\set VERBOSITY terse
-- old-pllua compat shims
do language pllua_ng $$
  function fromstring(t,s) return pgtype(nil,t):fromstring(s) end
  function setshared(k,v) _ENV[k] = v end
  server.execute = spi.execute
  server.rows = spi.rows
  server.prepare = spi.prepare
  shared = _G
$$;
--
-- tests taken from old pllua
-- minimal function
CREATE FUNCTION hello(name text)
RETURNS text AS $$
  return string.format("Hello, %s!", name)
$$ LANGUAGE pllua_ng;
SELECT hello('PostgreSQL');
       hello        
--------------------
 Hello, PostgreSQL!
(1 row)

-- null handling
CREATE FUNCTION max(a integer, b integer) RETURNS integer AS $$
  if a == nil then return b end -- first arg is NULL?
  if b == nil then return a end -- second arg is NULL?
  return a > b and a or b -- return max(a, b)
$$ LANGUAGE pllua_ng;
SELECT max(1,2), max(2,1), max(2,null), max(null, 2), max(null, null);
 max | max | max | max | max 
-----+-----+-----+-----+-----
   2 |   2 |   2 |   2 |    
(1 row)

-- plain recursive
CREATE FUNCTION fib(n int) RETURNS int AS $$
  if n < 3 then
    return n
  else
    return fib(n - 1) + fib(n - 2)
  end
$$ LANGUAGE pllua_ng;
SELECT fib(4);
 fib 
-----
   5
(1 row)

-- memoized
CREATE FUNCTION fibm(n integer) RETURNS integer AS $$
  if n < 3 then return n
  else
    local v = _U[n]
    if not v then
      v = fibm(n - 1) + fibm(n - 2)
      _U[n] = v
    end
    return v
  end
end
do _U = {}
$$ LANGUAGE pllua_ng;
SELECT fibm(4);
 fibm 
------
    5
(1 row)

-- tail recursive
CREATE FUNCTION fibt(n integer) RETURNS integer AS $$
  return _U(n, 0, 1)
end
_U = function(n, a, b)
  if n < 1 then return b
  else return _U(n - 1, b, a + b) end
$$ LANGUAGE pllua_ng;
SELECT fibt(4);
 fibt 
------
    5
(1 row)

-- iterator
CREATE FUNCTION fibi() RETURNS integer AS $$
  while true do
    _U.curr, _U.next = _U.next, _U.curr + _U.next
    coroutine.yield(_U.curr)
  end
end
do
  _U = {curr = 0, next = 1}
  fibi = coroutine.wrap(fibi)
$$ LANGUAGE pllua_ng;
SELECT fibi(), fibi(), fibi(), fibi(), fibi();
 fibi | fibi | fibi | fibi | fibi 
------+------+------+------+------
    1 |    1 |    2 |    3 |    5
(1 row)

SELECT fibi(), fibi(), fibi(), fibi(), fibi();
 fibi | fibi | fibi | fibi | fibi 
------+------+------+------+------
    8 |   13 |   21 |   34 |   55
(1 row)

-- upvalue
CREATE FUNCTION counter() RETURNS int AS $$
  while true do
    _U = _U + 1
    coroutine.yield(_U)
  end
end
do
  _U = 0 -- counter
  counter = coroutine.wrap(counter)
$$ LANGUAGE pllua_ng;
SELECT counter();
 counter 
---------
       1
(1 row)

SELECT counter();
 counter 
---------
       2
(1 row)

SELECT counter();
 counter 
---------
       3
(1 row)

-- record input
CREATE TYPE greeting AS (how text, who text);
CREATE FUNCTION makegreeting (g greeting, f text) RETURNS text AS $$
  return string.format(f, g.how, g.who)
$$ LANGUAGE pllua_ng;
SELECT makegreeting(('how', 'who'), '%s, %s!');
 makegreeting 
--------------
 how, who!
(1 row)

-- no worky yet
-- array, record output
CREATE FUNCTION greetingset (how text, who text[])
RETURNS SETOF greeting AS $$
  for _, name in ipairs(who) do
    coroutine.yield{how=how, who=name}
  end
$$ LANGUAGE pllua_ng;
SELECT makegreeting(greetingset, '%s, %s!') FROM
  (SELECT greetingset('Hello', ARRAY['foo', 'bar', 'psql'])) AS q;
 makegreeting 
--------------
 Hello, foo!
 Hello, bar!
 Hello, psql!
(3 rows)

-- more array, upvalue
CREATE FUNCTION perm (a text[]) RETURNS SETOF text[] AS $$
  _U(a, #a)
end
do
  _U = function (a, n) -- permgen in PiL
    if n == 0 then
      coroutine.yield(a) -- return next SRF row
    else
      for i = 1, n do
        a[n], a[i] = a[i], a[n] -- i-th element as last one
        _U(a, n - 1) -- recurse on head
        a[n], a[i] = a[i], a[n] -- restore i-th element
      end
    end
  end
$$ LANGUAGE pllua_ng;
SELECT * FROM perm(array['1', '2', '3']);
  perm   
---------
 {2,3,1}
 {3,2,1}
 {3,1,2}
 {1,3,2}
 {2,1,3}
 {1,2,3}
(6 rows)

-- shared variables
CREATE FUNCTION getcounter() RETURNS integer AS $$
  if shared.counter == nil then -- not cached?
    setshared("counter", 0)
  end
  return counter -- _G.counter == shared.counter
$$ LANGUAGE pllua_ng;
CREATE FUNCTION setcounter(c integer) RETURNS void AS $$
  if shared.counter == nil then -- not cached?
    setshared("counter", c)
  else
    counter = c -- _G.counter == shared.counter
  end
$$ LANGUAGE pllua_ng;
SELECT getcounter();
 getcounter 
------------
          0
(1 row)

SELECT setcounter(5);
 setcounter 
------------
 
(1 row)

SELECT getcounter();
 getcounter 
------------
          5
(1 row)

-- SPI usage
CREATE TABLE sometable ( sid int4, sname text, sdata text);
INSERT INTO sometable VALUES (1, 'name', 'data');
CREATE FUNCTION get_rows (i_name text) RETURNS SETOF sometable AS $$
  if _U == nil then -- plan not cached?
    local cmd = "SELECT sid, sname, sdata FROM sometable WHERE sname = $1"
    _U = server.prepare(cmd, {"text"}):save()
  end
  local c = _U:getcursor(i_name)
  while true do
    local r = c:fetch(1)
    if #r < 1 then break end
    r = r[1]
    coroutine.yield{sid=r.sid, sname=r.sname, sdata=r.sdata}
  end
  c:close()
$$ LANGUAGE pllua_ng;
SELECT * FROM get_rows('name');
 sid | sname | sdata 
-----+-------+-------
   1 | name  | data
(1 row)

SET client_min_messages = warning;
CREATE TABLE tree (id INT PRIMARY KEY, lchild INT, rchild INT);
RESET client_min_messages;
CREATE FUNCTION filltree (t text, n int) RETURNS void AS $$
  local p = server.prepare("insert into " .. t .. " values($1, $2, $3)",
    {"int4", "int4", "int4"})
  for i = 1, n do
    local lchild, rchild = 2 * i, 2 * i + 1 -- siblings
    p:execute(i, lchild, rchild) -- insert values
  end
$$ LANGUAGE pllua_ng;
SELECT filltree('tree', 10);
 filltree 
----------
 
(1 row)

CREATE FUNCTION preorder (t text, s int) RETURNS SETOF int AS $$
  coroutine.yield(s)
  local q = server.execute("select * from " .. t .. " where id=" .. s)
  if #q > 0 then
    local lchild, rchild = q[1].lchild, q[1].rchild -- store before next query
    if lchild ~= nil then preorder(t, lchild) end
    if rchild ~= nil then preorder(t, rchild) end
  end
$$ LANGUAGE pllua_ng;
SELECT * from preorder('tree', 1);
 preorder 
----------
        1
        2
        4
        8
       16
       17
        9
       18
       19
        5
       10
       20
       21
       11
        3
        6
       12
       13
        7
       14
       15
(21 rows)

CREATE FUNCTION postorder (t text, s int) RETURNS SETOF int AS $$
  local p = _U[t]
  if p == nil then -- plan not cached?
    p = server.prepare("select * from " .. t .. " where id=$1", {"int4"})
    _U[t] = p:save()
  end
  local c = p:getcursor(s)
  local q = c:fetch(1) -- one row
  if #q > 0 then
    local lchild, rchild = q[1].lchild, q[1].rchild -- store before next query
    c:close()
    if lchild ~= nil then postorder(t, lchild) end
    if rchild ~= nil then postorder(t, rchild) end
  end
  coroutine.yield(s)
end
do _U = {} -- plan cache
$$ LANGUAGE pllua_ng;
SELECT * FROM postorder('tree', 1);
 postorder 
-----------
        16
        17
         8
        18
        19
         9
         4
        20
        21
        10
        11
         5
         2
        12
        13
         6
        14
        15
         7
         3
         1
(21 rows)

-- trigger
CREATE FUNCTION treetrigger() RETURNS trigger AS $$
  local row, operation = trigger.row, trigger.operation
  if operation == "update" then
    trigger.row = nil -- updates not allowed
  elseif operation == "insert" then
    local id, lchild, rchild = row.id, row.lchild, row.rchild
    if lchild == rchild or id == lchild or id == rchild -- avoid loops
        or (lchild ~= nil and _U.intree(lchild)) -- avoid cycles
        or (rchild ~= nil and _U.intree(rchild))
        or (_U.nonemptytree() and not _U.isleaf(id)) -- not leaf?
        then
      trigger.row = nil -- skip operation
    end
  else -- operation == "delete"
    if not _U.isleafparent(row.id) then -- not both leaf parent?
      trigger.row = nil
    end
  end
end
do
  local getter = function(cmd, ...)
    local plan = server.prepare(cmd, {...}):save()
    return function(...)
      return #(plan:execute(...)) > 0
    end
  end
  _U = { -- plan closures
    nonemptytree = getter("select * from tree"),
    intree = getter("select node from (select id as node from tree "
      .. "union select lchild from tree union select rchild from tree) as q "
      .. "where node=$1", "int4"),
    isleaf = getter("select leaf from (select lchild as leaf from tree "
      .. "union select rchild from tree except select id from tree) as q "
      .. "where leaf=$1", "int4"),
    isleafparent = getter("select lp from (select id as lp from tree "
      .. "except select ti.id from tree ti join tree tl on ti.lchild=tl.id "
      .. "join tree tr on ti.rchild=tr.id) as q where lp=$1", "int4")
  }
$$ LANGUAGE pllua_ng;
CREATE TRIGGER tree_trigger BEFORE INSERT OR UPDATE OR DELETE ON tree
  FOR EACH ROW EXECUTE PROCEDURE treetrigger();
SELECT * FROM tree WHERE id = 1;
 id | lchild | rchild 
----+--------+--------
  1 |      2 |      3
(1 row)

UPDATE tree SET rchild = 1 WHERE id = 1;
SELECT * FROM tree WHERE id = 10;
 id | lchild | rchild 
----+--------+--------
 10 |     20 |     21
(1 row)

DELETE FROM tree where id = 10;
DELETE FROM tree where id = 1;
-- passthru types
CREATE FUNCTION echo_int2(arg int2) RETURNS int2 AS $$ return arg $$ LANGUAGE pllua_ng;
SELECT echo_int2('12345');
 echo_int2 
-----------
     12345
(1 row)

CREATE FUNCTION echo_int4(arg int4) RETURNS int4 AS $$ return arg $$ LANGUAGE pllua_ng;
SELECT echo_int4('1234567890');
 echo_int4  
------------
 1234567890
(1 row)

CREATE FUNCTION echo_int8(arg int8) RETURNS int8 AS $$ return arg $$ LANGUAGE pllua_ng;
SELECT echo_int8('1234567890');
 echo_int8  
------------
 1234567890
(1 row)

SELECT echo_int8('12345678901236789');
     echo_int8     
-------------------
 12345678901236789
(1 row)

SELECT echo_int8('1234567890123456789');
      echo_int8      
---------------------
 1234567890123456789
(1 row)

CREATE FUNCTION echo_text(arg text) RETURNS text AS $$ return arg $$ LANGUAGE pllua_ng;
SELECT echo_text('qwe''qwe');
 echo_text 
-----------
 qwe'qwe
(1 row)

CREATE FUNCTION echo_bytea(arg bytea) RETURNS bytea AS $$ return arg $$ LANGUAGE pllua_ng;
SELECT echo_bytea('qwe''qwe');
    echo_bytea    
------------------
 \x71776527717765
(1 row)

SELECT echo_bytea(E'q\\000w\\001e''q\\\\we');
       echo_bytea       
------------------------
 \x710077016527715c7765
(1 row)

CREATE FUNCTION echo_timestamptz(arg timestamptz) RETURNS timestamptz AS $$ return arg $$ LANGUAGE pllua_ng;
SELECT echo_timestamptz('2007-01-06 11:11 UTC') AT TIME ZONE 'UTC';
         timezone         
--------------------------
 Sat Jan 06 11:11:00 2007
(1 row)

CREATE FUNCTION echo_timestamp(arg timestamp) RETURNS timestamp AS $$ return arg $$ LANGUAGE pllua_ng;
SELECT echo_timestamp('2007-01-06 11:11');
      echo_timestamp      
--------------------------
 Sat Jan 06 11:11:00 2007
(1 row)

CREATE FUNCTION echo_date(arg date) RETURNS date AS $$ return arg $$ LANGUAGE pllua_ng;
SELECT echo_date('2007-01-06');
 echo_date  
------------
 01-06-2007
(1 row)

CREATE FUNCTION echo_time(arg time) RETURNS time AS $$ return arg $$ LANGUAGE pllua_ng;
SELECT echo_time('11:11');
 echo_time 
-----------
 11:11:00
(1 row)

CREATE FUNCTION echo_arr(arg text[]) RETURNS text[] AS $$ return arg $$ LANGUAGE pllua_ng;
SELECT echo_arr(array['a', 'b', 'c']);
 echo_arr 
----------
 {a,b,c}
(1 row)

CREATE DOMAIN mynum AS numeric(6,3);
CREATE FUNCTION echo_mynum(arg mynum) RETURNS mynum AS $$ return arg $$ LANGUAGE pllua_ng;
SELECT echo_mynum(666.777);
 echo_mynum 
------------
    666.777
(1 row)

CREATE TYPE mytype AS (id int2, val mynum, val_list numeric[]);
CREATE FUNCTION echo_mytype(arg mytype) RETURNS mytype AS $$ return arg $$ LANGUAGE pllua_ng;
SELECT echo_mytype((1::int2, 666.777, array[1.0, 2.0]) );
       echo_mytype       
-------------------------
 (1,666.777,"{1.0,2.0}")
(1 row)

CREATE FUNCTION nested_server_rows () RETURNS SETOF text as
$$
for left in server.rows('select generate_series as left from generate_series(3,4) ') do
for right in server.rows('select generate_series as right from generate_series(5,6) ') do
	local s = left.left.." "..right.right
	coroutine.yield(s)
end
end
$$
language pllua_ng;
select nested_server_rows();
 nested_server_rows 
--------------------
 3 5
 3 6
 4 5
 4 6
(4 rows)

CREATE OR REPLACE FUNCTION pg_temp.srf()
RETURNS SETOF integer AS $$
  coroutine.yield(1)
  coroutine.yield(nil)
  coroutine.yield(2)
$$ LANGUAGE pllua_ng;
select quote_nullable(pg_temp.srf());
 quote_nullable 
----------------
 '1'
 NULL
 '2'
(3 rows)

CREATE OR REPLACE FUNCTION pg_temp.srf()
RETURNS SETOF integer AS $$
  coroutine.yield(1)
  coroutine.yield()
  coroutine.yield(2)
$$ LANGUAGE pllua_ng;
select quote_nullable(pg_temp.srf());
 quote_nullable 
----------------
 '1'
 NULL
 '2'
(3 rows)

CREATE or replace FUNCTION pg_temp.inoutf(a integer, INOUT b text, INOUT c text)  AS
$$
begin
c = a||'c:'||c;
b = 'b:'||b;
end
$$
LANGUAGE plpgsql;
do $$
local a = server.execute("SELECT pg_temp.inoutf(5, 'ABC', 'd') as val ");
local r = a[1].val
print(r.b)
print(r.c)
$$ language pllua_ng;
INFO:  b:ABC
INFO:  5c:d
-- body reload
SELECT hello('PostgreSQL');
       hello        
--------------------
 Hello, PostgreSQL!
(1 row)

CREATE OR REPLACE FUNCTION hello(name text)
RETURNS text AS $$
  return string.format("Bye, %s!", name)
$$ LANGUAGE pllua_ng;
SELECT hello('PostgreSQL');
      hello       
------------------
 Bye, PostgreSQL!
(1 row)

--
--
-- new stuff
--
create type ctype3 as (fred integer, jim numeric);
do $$
  begin
    if current_setting('server_version_num')::integer >= 110000 then
      execute 'create domain dtype as ctype3 check((VALUE).jim is not null)';
    else
      execute 'create type dtype as (fred integer, jim numeric)';
    end if;
  end;
$$;
create type ctype2 as (thingy text, wotsit integer);
create type ctype as (foo text, bar ctype2, baz dtype);
create table tdata (
    intcol integer,
    textcol text,
    charcol char(32),
    varcharcol varchar(32),
    compcol ctype,
    dcompcol dtype
);
insert into tdata
values (1, 'row 1', 'padded with blanks', 'not padded', ('x',('y',1111),(111,11.1)), (11,1.1)),
       (2, 'row 2', 'padded with blanks', 'not padded', ('x',('y',2222),(222,22.2)), (22,2.2)),
       (3, 'row 3', 'padded with blanks', 'not padded', ('x',('y',3333),(333,33.3)), (33,3.3));
create function tf1() returns setof tdata language pllua_ng as $f$
  for i = 1,4 do
    coroutine.yield({ intcol = i,
                      textcol = "row "..i,
		      charcol = "padded with blanks",
		      varcharcol = "not padded",
		      compcol = { foo = "x",
		      	      	  bar = { thingy = "y", wotsit = i*1111 },
				  baz = { fred = i*111, jim = i*11.1 }
				},
		      dcompcol = { fred = i*11, jim = i*1.1 }
		    });
  end
$f$;
select * from tf1();
 intcol | textcol |             charcol              | varcharcol |           compcol           | dcompcol 
--------+---------+----------------------------------+------------+-----------------------------+----------
      1 | row 1   | padded with blanks               | not padded | (x,"(y,1111)","(111,11.1)") | (11,1.1)
      2 | row 2   | padded with blanks               | not padded | (x,"(y,2222)","(222,22.2)") | (22,2.2)
      3 | row 3   | padded with blanks               | not padded | (x,"(y,3333)","(333,33.3)") | (33,3.3)
      4 | row 4   | padded with blanks               | not padded | (x,"(y,4444)","(444,44.4)") | (44,4.4)
(4 rows)

--
-- various checks of type handling
--
do language pllua_ng $$ print(pgtype(nil,'ctype3')(1,2)) $$;
INFO:  (1,2)
do language pllua_ng $$ print(pgtype(nil,'ctype3')({1,2})) $$;
INFO:  (,)
do language pllua_ng $$ print(pgtype(nil,'ctype3')(true,true)) $$;
ERROR:  pllua: incompatible value type
do language pllua_ng $$ print(pgtype(nil,'ctype3')("1","2")) $$;
INFO:  (1,2)
do language pllua_ng $$ print(pgtype(nil,'ctype3')("fred","jim")) $$;
ERROR:  invalid input syntax for integer: "fred"
do language pllua_ng $$ print(pgtype(nil,'ctype3')({fred=1,jim=2})) $$;
INFO:  (1,2)
do language pllua_ng $$ print(pgtype(nil,'ctype3')({fred=1,jim={}})) $$;
ERROR:  pllua: incompatible value type
do language pllua_ng $$ print(pgtype(nil,'ctype3')({fred=1,jim=nil})) $$;
INFO:  (1,)
--do language pllua_ng $$ print(pgtype(nil,'dtype')({fred=1,jim=nil})) $$;
create function tf2() returns setof tdata language pllua_ng as $f$
  local t = spi.execute("select * from tdata")
  for i,v in ipairs(t) do coroutine.yield(v) end
$f$;
select * from tf2();
 intcol | textcol |             charcol              | varcharcol |           compcol           | dcompcol 
--------+---------+----------------------------------+------------+-----------------------------+----------
      1 | row 1   | padded with blanks               | not padded | (x,"(y,1111)","(111,11.1)") | (11,1.1)
      2 | row 2   | padded with blanks               | not padded | (x,"(y,2222)","(222,22.2)") | (22,2.2)
      3 | row 3   | padded with blanks               | not padded | (x,"(y,3333)","(333,33.3)") | (33,3.3)
(3 rows)

-- test numerics
create function lua_numexec(code text, n1 numeric, n2 numeric)
  returns text
  language pllua_ng
  as $$
    local f,e = load("return function(n1,n2) return "..code.." end")
    assert(f,e)
    f = f()
    assert(f)
    return tostring(f(n1,n2))
$$;
create function pg_numexec(code text, n1 numeric, n2 numeric)
  returns text
  language plpgsql
  as $$
    declare
      r text;
    begin
      execute format('select (%s)::text',
      	      	     regexp_replace(regexp_replace(code, '\mnum\.', '', 'g'),
		                    '\mn([0-9])', '$\1', 'g'))
	 into r using n1,n2;
      return r;
    end;
$$;
do language pllua_ng $$ num = require "pllua.numeric" $$;
with
  t as (select code,
               lua_numexec(code, 5439.123456, -1.9) as lua,
               pg_numexec(code, 5439.123456, -1.9) as pg
          from unnest(array[
		$$ n1 + n2 $$,		$$ n1 - n2 $$,
		$$ n1 * n2 $$,		$$ n1 / n2 $$,
		$$ n1 % n2 $$,		$$ n1 ^ n2 $$,
		$$ (-n1) + n2 $$,	$$ (-n1) - n2 $$,
		$$ (-n1) * n2 $$,	$$ (-n1) / n2 $$,
		$$ (-n1) % n2 $$,	$$ (-n1) ^ 3 $$,
		$$ (-n1) + (-n2) $$,	$$ (-n1) - (-n2) $$,
		$$ (-n1) * (-n2) $$,    $$ (-n1) / (-n2) $$,
		$$ (-n1) % (-n2) $$,	$$ (-n1) ^ (-3) $$,
		$$ (n1) > (n2) $$,	$$ (n1) < (n2) $$,
		$$ (n1) >= (n2) $$,	$$ (n1) <= (n2) $$,
		$$ (n1) > (n2*10000) $$,
		$$ (n1) < (n2*10000) $$,
		$$ (n1) >= (n2 * -10000) $$,
		$$ (n1) <= (n2 * -10000) $$,
		$$ num.round(n1) $$,    $$ num.round(n2) $$,
		$$ num.round(n1,4) $$,	$$ num.round(n1,-1) $$,
		$$ num.trunc(n1) $$,	$$ num.trunc(n2) $$,
		$$ num.trunc(n1,4) $$,	$$ num.trunc(n1,-1) $$,
		$$ num.floor(n1) $$,	$$ num.floor(n2) $$,
		$$ num.ceil(n1) $$,	$$ num.ceil(n2) $$,
		$$ num.abs(n1) $$,	$$ num.abs(n2) $$,
		$$ num.sign(n1) $$,	$$ num.sign(n2) $$,
		$$ num.sqrt(n1) $$,
		$$ num.exp(12.3) $$,
		$$ num.exp(n2) $$
  ]) as u(code))
select (lua = pg) as ok, * from t;
 ok |          code           |              lua               |               pg               
----+-------------------------+--------------------------------+--------------------------------
 t  |  n1 + n2                | 5437.223456                    | 5437.223456
 t  |  n1 - n2                | 5441.023456                    | 5441.023456
 t  |  n1 * n2                | -10334.3345664                 | -10334.3345664
 t  |  n1 / n2                | -2862.6965557894736842         | -2862.6965557894736842
 t  |  n1 % n2                | 1.323456                       | 1.323456
 t  |  n1 ^ n2                | 0.00000007989048519637487      | 0.00000007989048519637487
 t  |  (-n1) + n2             | -5441.023456                   | -5441.023456
 t  |  (-n1) - n2             | -5437.223456                   | -5437.223456
 t  |  (-n1) * n2             | 10334.3345664                  | 10334.3345664
 t  |  (-n1) / n2             | 2862.6965557894736842          | 2862.6965557894736842
 t  |  (-n1) % n2             | -1.323456                      | -1.323456
 t  |  (-n1) ^ 3              | -160911376260.9068713240072028 | -160911376260.9068713240072028
 t  |  (-n1) + (-n2)          | -5437.223456                   | -5437.223456
 t  |  (-n1) - (-n2)          | -5441.023456                   | -5441.023456
 t  |  (-n1) * (-n2)          | -10334.3345664                 | -10334.3345664
 t  |  (-n1) / (-n2)          | -2862.6965557894736842         | -2862.6965557894736842
 t  |  (-n1) % (-n2)          | -1.323456                      | -1.323456
 t  |  (-n1) ^ (-3)           | -0.0000000000062146            | -0.0000000000062146
 t  |  (n1) > (n2)            | true                           | true
 t  |  (n1) < (n2)            | false                          | false
 t  |  (n1) >= (n2)           | true                           | true
 t  |  (n1) <= (n2)           | false                          | false
 t  |  (n1) > (n2*10000)      | true                           | true
 t  |  (n1) < (n2*10000)      | false                          | false
 t  |  (n1) >= (n2 * -10000)  | false                          | false
 t  |  (n1) <= (n2 * -10000)  | true                           | true
 t  |  num.round(n1)          | 5439                           | 5439
 t  |  num.round(n2)          | -2                             | -2
 t  |  num.round(n1,4)        | 5439.1235                      | 5439.1235
 t  |  num.round(n1,-1)       | 5440                           | 5440
 t  |  num.trunc(n1)          | 5439                           | 5439
 t  |  num.trunc(n2)          | -1                             | -1
 t  |  num.trunc(n1,4)        | 5439.1234                      | 5439.1234
 t  |  num.trunc(n1,-1)       | 5430                           | 5430
 t  |  num.floor(n1)          | 5439                           | 5439
 t  |  num.floor(n2)          | -2                             | -2
 t  |  num.ceil(n1)           | 5440                           | 5440
 t  |  num.ceil(n2)           | -1                             | -1
 t  |  num.abs(n1)            | 5439.123456                    | 5439.123456
 t  |  num.abs(n2)            | 1.9                            | 1.9
 t  |  num.sign(n1)           | 1                              | 1
 t  |  num.sign(n2)           | -1                             | -1
 t  |  num.sqrt(n1)           | 73.750413259859093             | 73.750413259859093
 t  |  num.exp(12.3)          | 219695.98867213773             | 219695.98867213773
 t  |  num.exp(n2)            | 0.1495686192226351             | 0.1495686192226351
(45 rows)

  
--end
